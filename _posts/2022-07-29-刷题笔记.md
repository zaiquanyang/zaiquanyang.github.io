---
layout: post
title: åˆ·é¢˜ç¬”è®°
tags: LeetCode
---


## ğŸ‰ åŸºç¡€ç±»å‹é¢˜ç›®


## ğŸ‰ é“¾è¡¨

#### [141. ç¯å½¢é“¾è¡¨](https://leetcode.cn/problems/linked-list-cycle/)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        // åªæœ‰ 0 æˆ–è€… 1 ä¸ªèŠ‚ç‚¹ç›´æ¥è¿”å›false
        if(head == NULL || head->next == NULL) return false;

        // æ³¨æ„è¿™é‡ŒèŠ‚ç‚¹çš„åˆå§‹åŒ–slow = head; fast = head->next
        ListNode* slow = head;
        ListNode* fast = head->next;
        while(fast != slow){
            if(fast==nullptr || fast->next==nullptr) return false;
            fast = fast->next->next;
            slow = slow->next;
        }
        return true;
    }
};
```

## ğŸ‰ åŒæŒ‡é’ˆ

#### [165. æ¯”è¾ƒç‰ˆæœ¬å·](https://leetcode.cn/problems/compare-version-numbers/submissions/)

## ğŸ‰ è´ªå¿ƒç®—æ³•

#### [334.é€’å¢çš„ä¸‰å…ƒå­åºåˆ—](https://leetcode.cn/problems/increasing-triplet-subsequence/)


è§£æ³•ä¸€ï¼š
```c++
//ä¸ºäº†æ‰¾åˆ°é€’å¢çš„ä¸‰å…ƒå­åºåˆ—ï¼Œfirst å’Œ second åº”è¯¥å°½å¯èƒ½åœ°å°ï¼Œæ­¤æ—¶æ‰¾åˆ°é€’å¢çš„ä¸‰å…ƒå­åºåˆ—çš„å¯èƒ½æ€§æ›´å¤§
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        int len = nums.size();
        if(len < 3) return false;

        int min = nums[0], max = INT_MAX;

        for(int i=1; i<len; i++){
            if(nums[i] > max) {
                return true;
            }
            else if(nums[i] > min) {
                max = nums[i];
            }
            else {
                min = nums[i];
            }
        }
        return false;
    }
};
```

è§£æ³•äºŒï¼š
```c++

//ç»´æŠ¤ä¸¤ä¸ªæ•°ç»„left_min, right_max, left_min[i]ä¸º i å·¦ä¾§çš„æœ€å°å€¼ï¼Œright_max[i] ä¸º i å³ä¾§çš„æœ€å¤§å€¼ã€‚

class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        int len=nums.size();
        
        vector<int> left_min(len, 0);
        left_min[0] = nums[0];
        vector<int> right_max(len, 0);
        right_max[len-1] = nums[len-1];
        // ç»´æŠ¤æ•°ç»„ left_min
        for(int i=1; i < len; i++) {
            left_min[i] = min(left_min[i-1], nums[i]);
        }
        // ç»´æŠ¤æ•°ç»„ right_max
        for(int j=len-2; j>=0; j--) {
            right_max[j] = max(right_max[j+1], nums[j]);
        }
        for(int k=1; k<len-1; k++){
            if(nums[k]>left_min[k-1] && nums[k] <right_max[k+1]) return true;
        }
        return false;
    }
};
```

## ğŸ‰ åŠ¨æ€è§„åˆ’

####  [300.æœ€é•¿é€’å¢å­åºåˆ—](https://leetcode.cn/problems/longest-increasing-subsequence/)

è§£æ³•ä¸€ï¼šå®Œå…¨åŸºäºåŠ¨æ€è§„åˆ’
```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int len = nums.size();
        // å®šä¹‰dpæ•°ç»„å¹¶åˆå§‹åŒ–
        vector<int> dp(len, 1);
        // æ›´æ–°dpæ•°ç»„
        for(int i=1; i<len; i++) {
            for(int j=0; j<i; j++) {
                if(nums[i] > nums[j]) {
                    dp[i] = max(dp[i], dp[j]+1);
                }
            }
        }
        int res = 0;
        for(int k=0; k <len; k++){
            if(dp[k] > res) res = dp[k];
        }
        return res;
    }
};
```

è§£æ³•äºŒï¼šåŠ¨æ€è§„åˆ’+äºŒåˆ†æŸ¥æ‰¾

